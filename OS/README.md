# 👨🏻‍💻 운영체제

## 운영체제란?
운영체제는 컴퓨터 시스템의 **자원들을 효율적으로 관리**하며, 사용자가 컴퓨터를 보다 편리하게 사용할 수 있도록 도와주는 **소프트웨어**이다.

## 프로세스와 스레드
### 프로세스
프로세스(Process): 현재 실행중인 프로그램을 의미한다. 또한, 메모리에 적재되어 있으며 CPU를 할당받을 수 있다.

#### 프로세스의 구성요소
- **코드(Code)**  
  실행할 프로그램의 코드가 저장됨  
  컴파일 시 크기가 결정  
  
- **데이터(Data)**  
  **전역변수, 정적(static)변수, 정적 배열** 등 **컴파일 시 크기가 결정되는 것**들의 영역  
  컴파일 시 크기가 결정  
  
- **힙(Heap)**  
  **동적으로 할당된 객체**를 위한 영역  
  런타임 시 크기가 결정  

- **스택(Stack)**  
  **지역변수, 매개변수, 리턴값** 등 주로 함수호출을 위한 영역  
  런타임 시 크기가 결정  
  <br>
  
#### 프로세스의 상태
<img src="https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png" width="900" height="300">  

상태 | 설명
---- | ----
**new** | 프로세스가 새롭게 생성된 상태. 생성 후 Job Queue로 들어가 **메모리 할당을 기다림**
**ready** | 메모리를 할당 받은 후, ready queue에서 **CPU할당을 기다리는 상태**  
**running** | **cpu를 할당 받아** 실행되고 있는 상태
**waiting** | I/O작업으로 인해 blocked 된 상태
**terminated** | 프로세스가 종료된 상태  
<br>

#### 프로세스 제어 블록 (PCB, Process Control Block)
PCB는 프로세스의 정보를 저장하는 운영체제의 자료구조이다. **각 프로세스마다 독립적인 PCB를 가지고 있다.**  
프로세스는 한 번 CPU를 할당 받은 후, 한 번에 작업을 처리하지 못하고 다시 ready queue로 돌아가야할 상황이 발생한다. 
이때, 어디까지 실행했는 지 저장하기 위해서 PCB가 필요하다. 
<br>
#### PCB의 구성 요소
- **프로세스 식별자(PID)**
- **프로세스 상태**
- **프로그램 카운터**: 다음에 실행할 명령어의 주소
- **메모리 관련정보**: 페이지 테이블, 세그먼트 테이블 등
- CPU 레지스터
- CPU 스케줄링 정보: 프로세스의 우선순위, 스케줄큐에 대한 포인터
<br><br>

### 스레드 
**스레드(Thread)**: 스레드는 프로세스의 실행 단위이다. 스레드는 **각각의 독립적인 스레드 식별자, 프로그램 카운터, 스택을 갖고있다.**  
모든 스레드는 **프로세스 내 코드, 데이터, 힙 영역의 자원을 공유한다.**

<br>

### 멀티 스레드 vs 멀티 프로세스
#### 멀티 스레드
- 스레드끼리 **코드, 데이터, 힙 영역을 공유**하므로, 스레드간 통신에 들어가는 비용이 적다
- context switch의 경우, **cash memory를 비울 필요가 없어 문맥전환이 빠르다**
- 데이터, 힙 영역을 공유하므로, **공유 데이터에 대한 동기화 작업이 필요하다**<br>

#### 멀티 프로세스
- 각 **프로세스가 독립적** -> 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않는다
- 자원을 공유하지 않으므로, **프로세스간 통신에 들어가는 비용이 크다**
- context switch의 경우, **cash memory를 비워야하므로 문맥전환이 느리다**
<br>


### 동시성과 병렬성
- **동시성 (Concurrency)**  <br>  

  T1 | T2 | T3 | T4 | T1 | T2 | T3 | T4 | T1
  ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
  
  조금씩 여러개의 Task를 진행할 수 있는 것
  
- **병렬성 (Parallelism)** <br>
  core 1  
  T1 | T3 | T2 | T4 | T1 
  ---- | ---- | ---- | ---- | ----  
  
  core 2
  T3 | T2 | T1 | T3 | T2 
  ---- | ---- | ---- | ---- | ----
  
  같은 시간에 동시에 여러개의 Task를 수행할 수 있는 것  
  
  <br>
### 다중 코어 프로그래밍 (다중 처리기 시스템)
가장 먼저 알아야 하는 전제는 **하나의 코어는 한 번에 오직 하나의 스레드만 실행할 수 있다.**  따라서 **단일 코어 시스템**(CPU가 하나)에서 4개의 스레드로 실행되는 응용 프로그램을 실행한다면, 이는 단순히 스레드의 실행이 시간에 따라 교대로 실행됨을 의미한다. 즉, 병렬성이 아닌 **동시성** 환경을 제공한다. 반면에, **여러 코어**를 가진 시스템에서는 시스템이 개별 스레드를 **각 코어**에 배정할 수 있으므로, **병렬성**을 환경을 제공할 수 있다.

**🌟 그렇다면 하나의 코어에 여러개의 쓰레드가 장착된 프로세서는 ???**  
여전히 하나의 코어는 한 번에 오직 하나의 스레드만 실행할 수 있다. 단, 하나의 코어가 N개의 스레드를 지원한다면, 여러 스레드가 코어에 적재됨으로써 **빠른 문맥 교환이 가능하다.** 즉, 코어당 스레드 한 개인 프로세서 보다는 빠르지만, **N배의 속도를 낼 수 있는 것은 아니다.**. 단, 인텔의 하이퍼 스레딩 기술이 적용된 프로세서는 하나의 코어에서 N개의 스레드를 동시에 실행 할 수 있다.
<br><br><br>
***

## 스케줄러
프로세스 스케줄링을 위한 Queue는 세가지가 있다  
- **Job Queue**: 현재 시스템 내에 실행중인 모든 프로세스의 집합  
- **Ready Queue**: **Job Scheduler**에 의해 **메모리**를 할당받은 후, **CPU** 할당을 기다리는 프로세스의 집합    
- **Device Queue**: I/O작업을 기다리는 프로세스의 집합  
이러한 Queue에 각 프로세스를 배정하는 역할을 스케줄러가 담당한다. 운영체제에는 세가지 프로세스 스케줄러가 존재한다  

### 장기 스케줄러
**Job Queue**에 있는 프로세스들 중 어떤 프로세스를 **Ready Queue**로 보낼지를 결정한다  
- 디스크에 적재되어 있는 프로세스 중 어떤 프로세스에게 **메모리**를 할당할 지를 결정  
- Degree of multiprogramming 제어 (실행중인 프로세스의 수 제어)  
- 프로세스 상태
  **new -> ready**  
- **현대의 시분할 시스템에서는 장기스케줄러가 없는 경우가 대부분**  

#### ✨ 장기 스케줄러가 없다면 무한히 생성되는 프로세스를 어떻게 제어하는가 ??
현대 시분할 시스템에서는 장기 스케줄러 대신 **중기 스케줄러**가 메모리 관리를 담당하고 있다.  
<br>  

### 단기 스케줄러
- **Ready Queue**에 있는 프로세스들 중 어떤 프로세스에게 **cpu**를 할당하여 실행할 지를 결정  
- 프로세스 상태  
  **ready -> running -> waiting -> ready**
- 스레드를 제공하는 운영체제에서는 실질적으로 프로세스가 아닌 **스레드**수준의 스케줄링  
<br>  

### 중기 스케줄러
- 메모리 부족시 프로세스를 메모리에서 디스크로 쫓아냄(Swap out)  
- cpu가 아닌 **memory**제어  
- Degree of multiprogramming 제어 (실행중인 프로세스의 수 제어)  
- 프로세스 상태  
  **ready -> suspended**  

#### ✨ suspended vs waiting(blocked)  
- **waiting(blocked)**: I/O 작업을 기다리는 상태. I/O 작업이 완료되면 다시 **ready queue로 돌아갈 수 있다.**  
- **suspended**: **외부적인 이유**로 실행이 정지된 상태. 메모리에서 디스크로 쫓겨난 상태. **외부(사용자)에서 재개시키지 않는 한 스스로 활성화할 수 없다.**  
<br>

  
## CPU 스케줄링
다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 **항상 실행 중인 프로세스를 가지게 하는 것이다.** 즉, 어떤 프로세스가 I/O 작업과 같이 대기해야하는 상황에 놓인 경우, 운영체제는 cpu를 해당 프로세스로부터 **회수하고 다른 프로세스에게 할당해야 한다.** 이러한 작업을 **CPU 스케줄링**이라 한다. 스레드를 지원하는 운영체제에서는 실질적으로 프로세스가 아니라 **스레드** 수준의 스케줄링을 진행한다.  
<br>

## 시스템의 종류
- 일괄처리 시스템
  - **일정량 혹은 일정 기간 동안 쌓인 데이터를 한 번에 일괄적으로 처리하는 시스템**
  - I/O작업 발생 시 cpu는 대기해야 하므로 유휴시간이 길어짐
  - **Turn around time이 길다**
  - Turn around time : 작업 요청부터 작업완료까지 걸린 시간
  
- 다중 프로그래밍 시스템
  - 메모리의 사용자영역에 프로그램이 여러개 탑재되어 있고, CPU가 이를 번갈아가며 수행한다 (동시성을 보장한다)
  - I/O작업으로 인한 **CPU 유휴 시간을 줄이기 위해 고안**
  - **단, I/O작업이 일어나야만 Context Switch가 발생함**
  - 한 프로그램이 무한루프에 빠지면 Context Switch도 발생하지 않아 시스템에 치명적
 
- **시분할 시스템**
  - **CPU의 전체 사용시간을 작은 작업 시간량으로 쪼개어 그 시간량 동안만 번갈아가면서 CPU를 할당하여 각 작업을 처리**
  - **Round Robin 방식이라고도 함**
  - **타이머 인터럽트를 통해 Context Switch 발생** 
  - **장기 스케줄러를 대신해 중기 스케줄러가 메모리 관리**

- 다중 처리 시스템
  - **여러개의 CPU**와 하나의 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
  - 하나의 CPU가 고장나더라도 다른 CPU를 이용하여 업무를 처리할 수 있으므로 신뢰성 및 안전성 증가
  
- 실시간 처리 시스템
  - 공장 생산 라인, 항공기/미사일 제어 등 엄격한 데드라인이 요구되는 곳에서 사용하는 시스템
  - 하드웨어와 완전히 밀착된 SW를 개발하여 처리 속도를 최우선시 함
